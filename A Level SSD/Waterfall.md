A traditional approach evolved from the construction industry. Broken into distinct strictly sequential phases

## Pros

- **Simple** and easy to understand
	- Good for inexperienced devs
- **Easy** to **manage**
	- Clear stages/milestones
	- Easy to determine what to do in each stage

## Cons

- Cannot accommodate changing user requirements
	- Used for **smaller** projects with well defined requirements
	- Not good for long term projects
- Limited customer involvement
	- Involved at **start** to define requirements
	- Involved at **end** to test
	- Risks final product **not meeting customer's needs**
- Forward flow direction
	- No **feedback** guidance earlier stages
- Authoritarian project management
	- **Limited creativity**
	- Developers skills **constrained**
- Testing performed at end of lifecycle
	- Errors discovered late
	- Costly to fix
- Working software delivered late in the cycle
	-  Customers do not know if the right product is being built
- Integration performed at end
	- **Risky** as design problems may be uncovered
	- Costly to fix